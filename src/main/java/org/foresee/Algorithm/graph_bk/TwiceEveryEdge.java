package org.foresee.Algorithm.graph_bk;

public class TwiceEveryEdge {
	/**
	 * 练习22.2-9：给出一个O(V+E)时间的算法来计算图G中一条这样的路径，该路径正反向通过E中每条边恰好一次。
	 * 思路(没想出来)：以任意节点s按广度优先搜索，搜索后找到了一棵搜索树，对s到任意除节点s以外的节点的路径是有作用的，
	 * 其它路径都不会产生决定作用，走过去再走回来就行了。
	 * 在广度优先搜索时，出队后的节点，遍历邻接节点，如果遇到的是白色节点，说明应该走过去不回来，再往深了走走再回来，
	 * 遇到灰色和黑色节点，说明该路径对回来不构成影响，走过去立刻走回来就行了。
	 * 
	 * 网上思路：扩展为有向图，问题变成遍历所有边一次，且给边赋visit标志。（边赋属性的还没想好怎么弄）
	 */
	public static void findTwiceEdgePath(Graph graph) { 
		
	}
}
