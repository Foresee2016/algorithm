package org.foresee.Algorithm.lp;

// @formatter:off
/**
 * 算法里单纯形法用的多，但它针对精心设计的输入，最差的运行时间是指数的。椭球算法和内点法是多项式时间的，但实际上运行缓慢。
 * 
 * 标准型：所有约束都是不等式，最大化目标函数cTx，满足约束Ax<=b
 * 松弛型：所有约束都是等式（除了变量非负的约束）
 * 
 * 转换为标准型：
 * 1.目标函数式最小化，对目标函数系数取负号。
 * 2.有变量不具有非负约束。设xj不具有非负约束，那么把xj替换为xj1-xj2，增加非负约束xj1>=0, xj2>=0，
 *   目标函数和约束中的xj替换为(xj1-xj2)，新的规划的解对应原问题的解，且具有相同目标值。
 * 3.等式约束，是等号而不是小于等于号。将x=y转化为x>=y和x<=y。
 * 4.不等式约束，不是小于等于而是大于等于，将大于等于的各乘-1，变成小于等于。
 * 
 * 转换线性规划为松弛型
 * 为了利用单纯形法高效求解，喜欢把线性规划转换为只有非负约束是不等式，其它的约束都是等式约束的形式。
 * 对于不等式约束sum(aij*xj)<=bi，引入新变量s=bi-sum(aij*xj)，称s是松弛变量，它度量了左右之间的松弛或差别。
 * 并让s>=0，保持约束等价。这个等式为真且s>=0这个不等式为真的情况下，原不等式为真。
 * 新引入x(n+i)来代表s，这样对于每个不等式都衍生出新的x(n+i)并且有x(n+i)>=0这个非负约束。新引入的叫基本变量，
 * 原先的叫非基本变量。并使用变量z表示目标函数值。
 * 
 * 用N表示非基本变量下标的集合，用B表示基本变量的下标集合，得到简洁定义的松弛型，用一个元祖(N, B, A, b, c, v)
 * z=v+sum(cj*xj)，
 * xi=bi-sum(aij*xj)，其中i属于B。
 * A、b、c中的下标不必是连续的整数，依赖于索引集合B和N。
 * 且aij是出现在松弛型中系数的负值，因为前边整体有减号。
 */
class Comment {
// @formatter:on

}
